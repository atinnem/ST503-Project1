---
title: "ST 590 Project 1"
author: "Amanda, adil & Brian"
date: "September 28, 2018"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## What is XML?
Extensible Markup Language, or XML, is a dynamic language that is similar to, but more flexible than HTML.  XML simplifies data sharing as it provides a flexible way to create information formats and electronically share structured data via the internet or corporate networks.<br> 
XML is self-defining, meaning the structure of data is embedded within the data itself.<br>
This feature removes the need to pre-build the structure to store the data when attempting to share it.  
The main advantage of XML is its simplicity.<br>
It enables you to consolidate large chunks of information into an XML document which provides structure and organization to the information.  This feature facilitates the rendering of such data in the website environment.<br>
You can learn more about XML here: <br> 
<https://searchmicroservices.techtarget.com/definition/XML-Extensible-Markup-Language> 
<https://www.w3schools.com/xml/xml_whatis.asp> <br>
<https://www.sitepoint.com/really-good-introduction-xml/> <br>

## Where does it get used? 
XML is useful in data transfer.<br>
Attempting to share or exchange data in incompatible formats is time consuming at best.<br>
As XML stores data in a plain text format, it is a platform independent way of storing and transporting data.

## Why is it a good way to store data?
XML is a good way to store complex and highly variable data, hierarchical data, and data in which the the format may change over time. 

## Loading libraries
```{r, warning = FALSE, message = FALSE}
library(tidyverse)
#requiring more packages that will be helpful later to handle XML data
library(XML)
library(methods)
library(plyr)
library(dplyr)
if (!require(lubridate)) {install.packages("lubridate")}
library(lubridate)
```


## Reading in XML data

We found a website with many public xml datasets, some of them contain very interesting information.<br> (http://aiweb.cs.washington.edu/research/projects/xmltk/xmldata/www/repository.html)
Mondial is an XML dataset from World geographic database integrated from the CIA World Factbook, the International Atlas, and the TERRA database among other sources.<br>
The data is made public and able to download from washington.edu datasets repository online.

Adil / Amanda, the XML dataset of Mondial has inconsistent number of nodes and/or subnodes throughout the XML content structure. It seems that we can't use standard protocols to fix those. We need to some ad hoc commands to make that work. Since this is for practice anyway, I suggest switching to another easier dataset called orders from the same repository, which I had success transforming it into XML. See code below. I commneted out the lines for Mondial in case we stil want to challenge ourselves later.

```{r Mondial}

# mondialParse <- xmlParse("http://aiweb.cs.washington.edu/research/projects/xmltk/xmldata/data/mondial/mondial-3.0.xml", useInternalNodes = TRUE)
# class(mondialParse)
# mondialParse

orderParse <- xmlParse("http://aiweb.cs.washington.edu/research/projects/xmltk/xmldata/data/tpc-h/orders.xml")
class(orderParse)
orderParse
```

## Transforming XML into a dataframe
```{r xmlToDF}

# xmlInList <- xmlToList(mondialParse)
# monialDF <- ldply(xmlInList, data.frame)
# Can't use the above methodology because number of nodes and subnodes are not consistent throughout the entire XML structure.

# monialDF <- xmlToDataFrame("http://aiweb.cs.washington.edu/research/projects/xmltk/xmldata/data/mondial/mondial-3.0.xml")
# This does not work either.

xmlInList <- xmlToList(orderParse)
orderDF <- ldply(xmlInList, data.frame)
orderTB <- tbl_df(orderDF)
str(orderTB)

```
The 2 quantitative variables are total price and the full order date. The 2 categorical variables we are going to explore are order priority and order status. For a concise breakdown between quantitative vs categorical variables, please refer to:<br> https://support.minitab.com/en-us/minitab/18/help-and-how-to/statistics/tables/supporting-topics/basics/categorical-and-quantitative-variables/

## Data Wrangling
All columns of data are parsed into factors, so we need to convert them to characters or numeric before manipulating them.
```{r data conversion}
# Make a copy so that orderTB is intact
orderTB_copy <- orderTB

# start converting columns
orderTB_copy$O_TOTALPRICE <- as.numeric(levels(orderTB$O_TOTALPRICE))[orderTB$O_TOTALPRICE]
orderTB_copy$O_ORDERDATE <- as.character(levels(orderTB$O_ORDERDATE))[orderTB$O_ORDERDATE]

# If f is a factor, as.numeric(levels(f))[f] is more efficient than as.numeric(as.character(f)) according to R documentation. That is what we used above.

# Convert order date from string to date type
d <- orderTB$O_ORDERDATE
parsedDate <- as.Date(d,"%Y-%m-%d")

# Check if date conversion is successful
class(parsedDate)

orderTB_copy$O_ORDERDATE <- parsedDate

str(orderTB_copy)

```

## Variable Creation
Create a variable to indicate which season the order was made. Use definition of seasons from northern hemisphere.
```{r}

m <- month(orderTB_copy$O_ORDERDATE)

# Use ifelse for vectorized operation
Season <- ifelse(m >= 3 & m <= 5, "Spring", ifelse(m >= 6 & m <= 8, "Summer", ifelse(m >= 9 & m <= 11, "Autumn", "Winter")))
orderTB_copy$Season <- factor(Season)

```

## Aggregation summary

Using the Order date and the newly created season varible to aggregate some data.
Mean and Median by Year
standard deviation by season

```{r Summaries}

sumOrderData <- orderTB_copy %>% group_by(year(O_ORDERDATE)) %>% summarize(meanPrice = mean(O_TOTALPRICE, na.rm = TRUE), medianPrice = median(O_TOTALPRICE, na.rm = TRUE), sdPrice = sd(O_TOTALPRICE, na.rm = TRUE))
sumOrderData

tapply(X=orderTB_copy$O_TOTALPRICE, INDEX = orderTB_copy$Season, FUN = sd)

```




