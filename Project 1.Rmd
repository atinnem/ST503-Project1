---
title: "Project 1 Order Data Analysis"
author: "Amanda, adil & Brian"
date: "September 29, 2018"
output: 
  html_document:
    toc: true
    toc_depth: 0
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```
## What is XML?
Extensible Markup Language, or XML, is a dynamic language that is similar to, but more flexible than HTML.  XML simplifies data sharing as it provides a flexible way to create information formats and electronically share structured data via the internet or corporate networks.<br> 

XML is self-defining, meaning the structure of data is embedded within the data itself. This feature removes the need to pre-build the structure to store the data when attempting to share it.<br>

The main advantage of XML is its simplicity. It enables you to consolidate large chunks of information into an XML document which provides structure and organization to the information. This feature facilitates the rendering of such data in the website environment.<br>

You can learn more about XML here:<br>
<https://searchmicroservices.techtarget.com/definition/XML-Extensible-Markup-Language>,<br>
<https://www.w3schools.com/xml/xml_whatis.asp><br>
<https://www.sitepoint.com/really-good-introduction-xml/><br>

## Where does it get used? 
XML is useful in data transfer. Attempting to share or exchange data in incompatible formats is time consuming at best. As XML stores data in a plain text format, it is a platform independent way of storing and transporting data.

## Why is it a good way to store data?
XML is a good way to store complex and highly variable data, hierarchical data, and data in which the the format may change over time. 

##What package(s) should be used to read in XML data?
There are several ways and packages that could be used to read in XML data.  The 'XML' package has many online tutorials, help, and trouble shooting available.  This, along with the fact that it contains many functions that make it easy to access and convert your data make it our recommendation on reading in XML data.

## Loading libraries
```{r, warning = FALSE, message = FALSE}
library(tidyverse)
#requiring more packages that will be helpful later to handle XML data
library(XML)
library(methods)
library(plyr)
library(dplyr)
if (!require(lubridate)) {install.packages("lubridate")}
library(lubridate)
```


## Reading in XML Data

We found a website with many public XML datasets, some of them contain very interesting information.<br>
[XML data repository](http://aiweb.cs.washington.edu/research/projects/xmltk/xmldata/www/repository.html)<br>
Mondial is an XML dataset from World geographic database integrated from the CIA World Factbook, the International Atlas, and the TERRA database among other sources. The data is made public and able to download from Washington.edu datasets repository online.<br>

However,Mondial has inconsistent number of nodes and/or subnodes throughout the XML content structure. It seems that we can't use standard protocols to fix those. We need to do some ad hoc commands to make that work. As a result we are switching to another more structured dataset called orders from the same repository, which we had success transforming the XML. See code below. We commented out the lines for Mondial in case we still want to challenge ourselves later.

```{r Mondial}
# mondialParse <- xmlParse("http://aiweb.cs.washington.edu/research/projects/xmltk/xmldata/data/mondial/mondial-3.0.xml", useInternalNodes = TRUE)
# class(mondialParse)
# mondialParse

orderParse <- xmlParse("http://aiweb.cs.washington.edu/research/projects/xmltk/xmldata/data/tpc-h/orders.xml")
class(orderParse)
```

## Transforming XML into a Dataframe
```{r xmlToDF}
# xmlInList <- xmlToList(mondialParse)
# monialDF <- ldply(xmlInList, data.frame)
# Can't use the above methodology because number of nodes and subnodes are not consistent throughout the entire XML structure.

# monialDF <- xmlToDataFrame("http://aiweb.cs.washington.edu/research/projects/xmltk/xmldata/data/mondial/mondial-3.0.xml")
# This does not work either.

xmlInList <- xmlToList(orderParse)
orderDF <- ldply(xmlInList, data.frame)
orderTB <- tbl_df(orderDF)
str(orderTB)
```
The 2 quantitative variables are total price and the full order date. The 2 categorical variables we are going to explore are order priority and order status. For a concise breakdown between quantitative vs categorical variables, please refer to:<br> 
<https://support.minitab.com/en-us/minitab/18/help-and-how-to/statistics/tables/supporting-topics/basics/categorical-and-quantitative-variables/><br>

## Data Wrangling
All columns of data are parsed into factors, so we need to convert them to characters or numeric before manipulating them.
```{r Conversions}
# Remove the last attr row (with NAs) from XML and make a copy so that orderTB is intact
orderTB <- orderTB[-15001,]
orderTB_copy <- orderTB

# start converting columns
orderTB_copy$O_TOTALPRICE <- as.numeric(levels(orderTB$O_TOTALPRICE))[orderTB$O_TOTALPRICE]
orderTB_copy$O_ORDERDATE <- as.character(levels(orderTB$O_ORDERDATE))[orderTB$O_ORDERDATE]

# If f is a factor, as.numeric(levels(f))[f] is more efficient than as.numeric(as.character(f)) according to R documentation. That is what we used above.

# Convert order date from string to date type
d <- orderTB$O_ORDERDATE
parsedDate <- as.Date(d,"%Y-%m-%d")

# Check if date conversion is successful
class(parsedDate)

orderTB_copy$O_ORDERDATE <- parsedDate

str(orderTB_copy)
```

## Variable Creation
Create a variable to indicate which season the order was made. Use definition of seasons from northern hemisphere.
```{r Creation}

m <- month(orderTB_copy$O_ORDERDATE)


# Use ifelse for vectorized operation
Season <- ifelse(m >= 3 & m <= 5, "Spring", ifelse(m >= 6 & m <= 8, "Summer", ifelse(m >= 9 & m <= 11, "Autumn", "Winter")))

# Convert Season into a factor with defined levels (so that the seasons are sorted properly in the aggregation)
orderTB_copy$Season <- factor(Season, levels = c("Spring", "Summer", "Autumn", "Winter"))
orderTB_copy$Year <- as.integer(year(orderTB_copy$O_ORDERDATE))

```

## Aggregation Summary
Using the Order date and the newly created season variable to aggregate some data. Mean and Median by Year, standard deviation by season.
```{r Summaries}
# Since dplyr and plyr are invoked together, we need to specify dplyr::group_by and dplyr::summarize. Otherwise, we will get only 1 row of summary.
sumOrderData <- orderTB_copy %>% dplyr::group_by(Year, Season) %>% dplyr::summarize(meanPrice = mean(O_TOTALPRICE, na.rm = TRUE), medianPrice = median(O_TOTALPRICE, na.rm = TRUE), sdPrice = sd(O_TOTALPRICE, na.rm = TRUE))
sumOrderData

# Looking at standard deviation by season using tapply.
tapply(X=orderTB_copy$O_TOTALPRICE, INDEX = orderTB_copy$Season, FUN = sd)
```

## Scatter Plots with Coloring
```{r Scatter}
scatter <- ggplot(orderTB_copy, aes(x = O_ORDERDATE, y = O_TOTALPRICE)) 
scatter + geom_point(aes(col = Season)) + labs(x = "Date", y = "Total Order Price per Customer", title = "Transaction Record from 2002 - 2008", color = "Seasons")
```
The above plot is too crowded to see the pattern. Do a line plot using summary data instead.

```{r}
l <- ggplot(sumOrderData, aes(x = Year, y = meanPrice, color = Season))
l + geom_line() + labs(x = "Year", y = "Average Order Price", title = "Transaction trend from 2002 - 2008", color = "Seasons")
```

## Box Plots
```{r}
b <- ggplot(orderTB_copy, aes(x = as.factor(Year), y = O_TOTALPRICE))  + geom_boxplot(fill = "pink") + labs(x = "Year", y = "Total Order Price per Customer", title = "Boxplot of Total Order Price by year")
b
```
```{r}
b <- ggplot(orderTB_copy, aes(x = as.factor(Year), y = O_TOTALPRICE, fill = Season))  + geom_boxplot() + labs(x = "Year", y = "Total Order Price per Customer", title = "Boxplot of Total Order Price by Year and Season")
b
```

<<<<<<< HEAD
## Aggregation summary
```{r}
#I made 2 frequency tables. we can use one of these or a different one.  Should we re-order the factors for o_order.priority?
table(orderTB_copy$O_ORDER.PRIORITY, orderTB_copy$Season)
table(orderTB_copy$O_ORDERSTATUS, orderTB_copy$Season )

#Bar chart of median order price by year and season

g<-ggplot(sumOrderData, aes(x= Year, y = medianPrice))

g + geom_bar(aes(fill=Season), stat = "identity", position = "dodge") + labs(x = "Year", y = "Median Order Price per Season", title = "Bar Chart of Median Order Price by Year and Season")


```

=======
>>>>>>> 8aac0ee1e3209d3e64603f07bfe42b06d2df5ce7
